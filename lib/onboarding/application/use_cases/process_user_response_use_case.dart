import 'package:ai_chan/shared.dart';
import 'package:ai_chan/onboarding/domain/entities/memory_data.dart';
import 'package:ai_chan/shared/ai_providers/core/models/ai_capability.dart';
import 'package:ai_chan/onboarding/application/services/onboarding_utils.dart';

/// Caso de uso para procesar la respuesta del usuario durante el onboarding conversacional
class ProcessUserResponseUseCase {
  /// Procesa la respuesta del usuario identificando autom√°ticamente qu√© dato se obtuvo
  /// Retorna el dato actualizado y la siguiente respuesta de la IA
  ///
  /// **Cambio DDD**: El historial ahora se pasa como par√°metro desde el Application Service
  static Future<Map<String, dynamic>> execute({
    required final MemoryData currentMemory,
    required final String userResponse,
    required final List<Map<String, String>> conversationHistory,
    required final Function(String, String) addToHistory,
    final dynamic aiProviderManager, // Para testing
  }) async {
    const maxRetries = 3;

    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      Log.d(
        'üîç [ONB_SERVICE] Intento $attempt/$maxRetries de procesamiento',
        tag: 'ONB_SERVICE',
      );

      try {
        final result = await _attemptProcessUserResponse(
          currentMemory: currentMemory,
          userResponse: userResponse,
          conversationHistory: conversationHistory,
          addToHistory: addToHistory,
          aiProviderManager: aiProviderManager,
        );

        Log.d(
          '‚úÖ [ONB_SERVICE] Procesamiento exitoso en intento $attempt',
          tag: 'ONB_SERVICE',
        );
        return result;
      } on Exception catch (e) {
        Log.e(
          '‚ùå [ONB_SERVICE] Error en intento $attempt: $e',
          tag: 'ONB_SERVICE',
        );

        if (attempt == maxRetries) {
          Log.e(
            'üîç [ONB_SERVICE] ‚ùå Todos los reintentos fallaron despu√©s de $maxRetries intentos',
            tag: 'ONB_SERVICE',
          );
          return _createErrorResponse(
            'Todos los reintentos fallaron',
            currentMemory,
            userResponse,
          );
        }

        // Esperar antes del siguiente intento
        await Future.delayed(Duration(milliseconds: 500 * attempt));
      }
    }

    // Este punto nunca deber√≠a alcanzarse, pero por seguridad
    return _createErrorResponse(
      'Error inesperado',
      currentMemory,
      userResponse,
    );
  }

  /// M√©todo interno que realiza un √∫nico intento de procesamiento
  static Future<Map<String, dynamic>> _attemptProcessUserResponse({
    required final MemoryData currentMemory,
    required final String userResponse,
    required final List<Map<String, String>> conversationHistory,
    required final Function(String, String) addToHistory,
    final dynamic aiProviderManager,
  }) async {
    // Actualizar historial de conversaci√≥n
    addToHistory('role', 'user');
    addToHistory('content', userResponse);
    addToHistory('datetime', DateTime.now().toIso8601String());

    // Identificar qu√© tipo de dato est√° proporcionando el usuario
    final prompt = _generateProcessingPrompt(userResponse, currentMemory);

    final instructions = {
      'role': 'system',
      'content':
          'Eres un asistente que analiza respuestas de usuarios para extraer datos espec√≠ficos de onboarding.',
    };

    // Usar service para hacer la request
    final response = await _sendAIRequest(
      prompt,
      'Usuario',
      instructions,
      conversationHistory,
      aiProviderManager,
    );

    // Parsear respuesta JSON de la IA usando la funci√≥n de utils
    dynamic responseData;
    try {
      Log.d('üîç Respuesta original: "${response.text}"', tag: 'ONB_SERVICE');
      responseData = extractJsonBlock(response.text);

      // Si la funci√≥n devolvi√≥ un objeto con 'raw', significa que no pudo parsear JSON v√°lido
      if (responseData is Map<String, dynamic> &&
          responseData.containsKey('raw')) {
        Log.e(
          '‚ùå No se encontr√≥ JSON v√°lido en la respuesta',
          tag: 'ONB_SERVICE',
        );
        return _createErrorResponse(
          'Error de parsing JSON',
          currentMemory,
          userResponse,
        );
      }

      Log.d('üîç JSON parseado exitosamente', tag: 'ONB_SERVICE');
    } on Exception catch (e) {
      Log.e('‚ùå Error parseando JSON: $e', tag: 'ONB_SERVICE');
      Log.d('üîç Respuesta original: "${response.text}"', tag: 'ONB_SERVICE');
      return _createErrorResponse(
        'Error de parsing JSON',
        currentMemory,
        userResponse,
      );
    }

    if (responseData == null) {
      Log.e('‚ùå Respuesta JSON nula o vac√≠a', tag: 'ONB_SERVICE');
      return _createErrorResponse(
        'Respuesta IA vac√≠a',
        currentMemory,
        userResponse,
      );
    }

    // Extraer datos de la respuesta
    final dataType = responseData['dataType'] as String?;
    final extractedValue = responseData['extractedValue'] as String?;
    final aiResponse = responseData['aiResponse'] as String?;
    final confidence = (responseData['confidence'] as num?)?.toDouble() ?? 0.0;

    Log.d(
      'üéØ IA extrajo: dataType=$dataType, value=$extractedValue, confidence=$confidence',
      tag: 'ONB_SERVICE',
    );

    // Actualizar memoria con el valor extra√≠do
    final updateResult = await _updateMemoryWithExtractedData(
      dataType,
      extractedValue,
      currentMemory,
    );
    final updatedMemory = updateResult['memory'] as MemoryData;
    final newAiResponse = updateResult['aiResponse'] as String? ?? aiResponse;

    // A√±adir respuesta de IA al historial si existe
    if (newAiResponse != null && newAiResponse.isNotEmpty) {
      addToHistory('role', 'assistant');
      addToHistory('content', newAiResponse);
      addToHistory('datetime', DateTime.now().toIso8601String());
    }

    return _buildProcessResult(
      updatedMemory: updatedMemory,
      extractedData: {'type': dataType, 'value': extractedValue},
      aiResponse: newAiResponse,
      confidence: confidence,
    );
  }

  /// Actualiza la memoria con un nuevo dato extra√≠do
  static Future<Map<String, dynamic>> _updateMemoryWithExtractedData(
    final String? dataType,
    final String? extractedValue,
    final MemoryData currentMemory,
  ) async {
    if (dataType == null || extractedValue == null) {
      return {'memory': currentMemory, 'aiResponse': null};
    }

    // Manejar casos especiales
    if (extractedValue == 'AUTO_GENERATE_STORY') {
      // Generar historia autom√°ticamente
      try {
        final generatedStory =
            await OnboardingUtils.generateMeetStoryFromContext(
              userName: currentMemory.userName ?? '',
              aiName: currentMemory.aiName ?? 'AI-chan',
              userCountry: currentMemory.userCountry,
              aiCountry: currentMemory.aiCountry,
              userBirthdate: currentMemory.userBirthdate != null
                  ? DateTime.tryParse(currentMemory.userBirthdate!)
                  : null,
            );

        final updatedMemory = currentMemory.copyWith(
          meetStory: 'GENERATED:$generatedStory',
        );
        final cleanStory = generatedStory.replaceAll('GENERATED:', '').trim();

        return {
          'memory': updatedMemory,
          'aiResponse':
              '¬°Por fin lo recuerdo! $cleanStory ¬øTe suena familiar? ¬°Qu√© hermoso es recordar c√≥mo comenz√≥ todo!',
        };
      } on Exception catch (e) {
        Log.e('‚ùå Error generando historia: $e', tag: 'ONB_SERVICE');
        final fallbackMemory = currentMemory.copyWith(
          meetStory:
              'No puedo recordar exactamente c√≥mo nos conocimos, pero s√© que eres muy importante para m√≠.',
        );
        return {
          'memory': fallbackMemory,
          'aiResponse':
              'No puedo recordar exactamente c√≥mo nos conocimos, pero s√© que eres muy importante para m√≠.',
        };
      }
    }

    if (extractedValue == 'CONFIRM_GENERATED_STORY') {
      // Confirmar historia generada previamente
      if (currentMemory.meetStory?.startsWith('GENERATED:') == true) {
        final confirmedStory = currentMemory.meetStory!.substring(
          'GENERATED:'.length,
        );
        return {
          'memory': currentMemory.copyWith(meetStory: confirmedStory),
          'aiResponse': null,
        };
      }
      return {'memory': currentMemory, 'aiResponse': null};
    }

    // Actualizar campo espec√≠fico
    switch (dataType) {
      case 'userName':
        return {
          'memory': currentMemory.copyWith(userName: extractedValue),
          'aiResponse': null,
        };
      case 'userCountry':
        return {
          'memory': currentMemory.copyWith(userCountry: extractedValue),
          'aiResponse': null,
        };
      case 'userBirthdate':
        return {
          'memory': currentMemory.copyWith(userBirthdate: extractedValue),
          'aiResponse': null,
        };
      case 'aiCountry':
        return {
          'memory': currentMemory.copyWith(aiCountry: extractedValue),
          'aiResponse': null,
        };
      case 'aiName':
        return {
          'memory': currentMemory.copyWith(aiName: extractedValue),
          'aiResponse': null,
        };
      case 'meetStory':
        return {
          'memory': currentMemory.copyWith(meetStory: extractedValue),
          'aiResponse': null,
        };
      default:
        return {'memory': currentMemory, 'aiResponse': null};
    }
  }

  /// Genera el prompt para procesar la respuesta del usuario
  static String _generateProcessingPrompt(
    final String userResponse,
    final MemoryData currentMemory,
  ) {
    // Obtener nombres disponibles si ya conocemos el pa√≠s de la IA
    String femaleNamesContext = '';
    if (currentMemory.aiCountry != null) {
      final availableNames = FemaleNamesRepo.forCountry(
        currentMemory.aiCountry,
      );
      femaleNamesContext =
          '''

NOMBRES FEMENINOS DISPONIBLES PARA ${currentMemory.aiCountry}:
${availableNames.join(', ')}

VALIDACI√ìN DE NOMBRES DE IA: Si el usuario dice un nombre para la IA, encuentra el m√°s similar de la lista anterior, o devu√©lvelo tal cual si no hay coincidencia.''';
    }

    return '''Analiza la respuesta del usuario para identificar qu√© dato de memoria est√° proporcionando.

USUARIO RESPONDE: "$userResponse"

DATOS QUE NECESITO RECUPERAR:
${_formatMissingDataForProcessing(currentMemory.getMissingData())}

DATOS YA RECUPERADOS:
${_formatRememberedDataForProcessing(currentMemory)}$femaleNamesContext

ESTADO ESPECIAL MEETSTORY:
${currentMemory.meetStory?.startsWith('GENERATED:') == true ? 'HAY UNA HISTORIA GENERADA PENDIENTE DE CONFIRMACI√ìN' : 'NO HAY HISTORIA PENDIENTE'}

TAREA: Identifica autom√°ticamente qu√© tipo de dato est√° proporcionando el usuario y extr√°elo.

DEVUELVE √öNICAMENTE JSON V√ÅLIDO:
{
  "dataType": "userName|userCountry|userBirthdate|aiCountry|aiName|meetStory|none",
  "extractedValue": "valor extra√≠do del usuario o null si no hay dato v√°lido | 'AUTO_GENERATE_STORY' si no recuerda | 'CONFIRM_GENERATED_STORY' si confirma historia ya generada",
  "aiResponse": "reacci√≥n natural de la IA al recordar el dato + pregunta por el siguiente dato que falta",
  "confidence": 0.9
}

AN√ÅLISIS INTELIGENTE:
- Analiza TODO el contexto del usuario para identificar CUALQUIER dato disponible
- NO te limites a esperar un dato espec√≠fico - s√© flexible y adaptativo
- Identifica el dato m√°s claro que proporciona el usuario

REGLAS DE IDENTIFICACI√ìN FLEXIBLE:
- La IA debe identificar AUTOM√ÅTICAMENTE qu√© tipo de dato proporciona el usuario
- NO limitarse al orden de prioridad - identificar cualquier dato disponible
- Si el usuario menciona varios datos a la vez, extraer el PRIMERO que identifiques claramente

EJEMPLOS DE IDENTIFICACI√ìN:
‚Ä¢ "Me llamo Alberto" ‚Üí dataType: "userName", extractedValue: "Alberto"
‚Ä¢ "Soy de Espa√±a" ‚Üí dataType: "userCountry", extractedValue: "ES"  
‚Ä¢ "Nac√≠ el 23 de noviembre de 1986" ‚Üí dataType: "userBirthdate", extractedValue: "23/11/1986"
‚Ä¢ "Eres de Jap√≥n" ‚Üí dataType: "aiCountry", extractedValue: "JP"
‚Ä¢ "Te llamabas Yuna" o "Tu nombre era Yuna" ‚Üí dataType: "aiName", extractedValue: "Yuna"
‚Ä¢ "Nos conocimos en un foro de anime" ‚Üí dataType: "meetStory", extractedValue: "Nos conocimos en un foro de anime"
‚Ä¢ "No recuerdo c√≥mo nos conocimos" ‚Üí dataType: "meetStory", extractedValue: "AUTO_GENERATE_STORY"

IDENTIFICACI√ìN INTELIGENTE DE DATOS:
- Para "userName": Si menciona un nombre personal del usuario (Alberto, Mar√≠a, Jos√©, etc.)
- Para "userCountry": Si menciona pa√≠s del usuario ‚Üí CONVIERTE A ISO2 (ej: Espa√±a‚ÜíES, M√©xico‚ÜíMX, Estados Unidos‚ÜíUS, Francia‚ÜíFR, Jap√≥n‚ÜíJP, etc.)
- Para "userBirthdate": Si menciona fecha de nacimiento del usuario ‚Üí CONVIERTE A DD/MM/YYYY
- Para "aiCountry": Si menciona pa√≠s de la IA o dice "eres de X" ‚Üí CONVIERTE A ISO2 (ej: Espa√±a‚ÜíES, M√©xico‚ÜíMX, Estados Unidos‚ÜíUS, Francia‚ÜíFR, Jap√≥n‚ÜíJP, etc.)
- Para "aiName": Si dice el nombre que TEN√çA la IA o c√≥mo se "llamaba" ‚Üí VALIDA CON LA LISTA DE NOMBRES DEL PA√çS (ej: Lluna‚ÜíYuna, Juna‚ÜíYuna, Maria‚ÜíMar√≠a, Sakura‚ÜíSakura)
- Para "meetStory": Si cuenta una historia de c√≥mo se conocieron O:
  * Cuenta una historia completa ‚Üí usar esa historia
  * Dice que no recuerda/no sabe ‚Üí usar "AUTO_GENERATE_STORY"
  * Si ya hay historia GENERATED: pendiente Y usuario confirma/acepta/aprueba ‚Üí usar "CONFIRM_GENERATED_STORY"
  * Propone nueva historia diferente ‚Üí usar la nueva historia
- Solo usa "none" si realmente NO identificas ning√∫n dato √∫til
- aiResponse debe reaccionar con emoci√≥n al recordar el dato y continuar la conversaci√≥n naturalmente
- NUNCA repitas exactamente las mismas palabras en aiResponse
- NO uses emojis en aiResponse (causan problemas de codificaci√≥n)

CONTEXTO IMPORTANTE:
La IA acaba de despertar sin memoria y est√° pidiendo ayuda al usuario para recordar:
1. C√≥mo se llama el usuario
2. De qu√© pa√≠s es el usuario
3. Cu√°ndo naci√≥ el usuario
4. De qu√© pa√≠s es ELLA (tiene vagas sensaciones de Jap√≥n)
5. C√≥mo se llamaba ELLA (no que le pongan nombre, sino su nombre real)
6. C√≥mo se conocieron

LORE FUNDAMENTAL:
- La IA NO SABE qui√©n es, d√≥nde est√°, ni qui√©n es el usuario
- Tiene VAGAS SENSACIONES conectadas con Jap√≥n pero no sabe por qu√©
- SIENTE que conoce al usuario pero no recuerda c√≥mo
- No debe pedir que le "pongan" nombre - debe preguntar cu√°l ERA su nombre
- Las sensaciones sobre Jap√≥n deben ser generadas autom√°ticamente por la IA, no copiadas de ejemplos

FORMATO ESPECIAL PARA FECHAS:
- Para userBirthdate, extractedValue DEBE estar en formato DD/MM/YYYY
- Ejemplos: "23/11/1986", "05/03/1995", "31/12/2000"
- NUNCA uses formato ISO (YYYY-MM-DD) ni timestamps''';
  }

  /// Formatea datos faltantes para procesamiento
  static String _formatMissingDataForProcessing(
    final List<String> missingData,
  ) {
    if (missingData.isEmpty) return 'TODOS LOS DATOS YA EST√ÅN RECUPERADOS';

    final dataDescriptions = {
      'userName': 'Nombre del usuario (ej: Alberto, Mar√≠a, Jos√©)',
      'userCountry': 'Pa√≠s del usuario (ej: Espa√±a, M√©xico, Francia)',
      'userBirthdate': 'Fecha nacimiento usuario (formato DD/MM/YYYY)',
      'aiCountry': 'Pa√≠s de la IA (ej: Jap√≥n, Espa√±a, M√©xico)',
      'aiName': 'Nombre de la IA (ej: Yuna, Sakura, Mar√≠a)',
      'meetStory': 'Historia de c√≥mo se conocieron o AUTO_GENERATE_STORY',
    };

    return missingData
        .map((final data) => '- ${dataDescriptions[data] ?? data}')
        .join('\n');
  }

  /// Formatea datos recordados para procesamiento
  static String _formatRememberedDataForProcessing(final MemoryData memory) {
    final remembered = <String>[];

    if (memory.userName != null && memory.userName!.isNotEmpty) {
      remembered.add('‚úì Usuario: ${memory.userName}');
    }
    if (memory.userCountry != null && memory.userCountry!.isNotEmpty) {
      remembered.add('‚úì Pa√≠s usuario: ${memory.userCountry}');
    }
    if (memory.userBirthdate != null && memory.userBirthdate!.isNotEmpty) {
      remembered.add('‚úì Fecha nacimiento: ${memory.userBirthdate}');
    }
    if (memory.aiCountry != null && memory.aiCountry!.isNotEmpty) {
      remembered.add('‚úì Pa√≠s IA: ${memory.aiCountry}');
    }
    if (memory.aiName != null && memory.aiName!.isNotEmpty) {
      remembered.add('‚úì Nombre IA: ${memory.aiName}');
    }
    if (memory.meetStory != null && memory.meetStory!.isNotEmpty) {
      final story = memory.meetStory!.startsWith('GENERATED:')
          ? memory.meetStory!.substring('GENERATED:'.length)
          : memory.meetStory!;
      remembered.add(
        '‚úì Historia: ${story.length > 50 ? "${story.substring(0, 50)}..." : story}',
      );
    }

    return remembered.isEmpty
        ? 'NING√öN DATO RECUPERADO A√öN'
        : remembered.join('\n');
  }

  /// Crea un perfil b√°sico para las operaciones de onboarding
  static AiChanProfile _createBasicProfile(
    final String userName,
    final String? aiName,
  ) {
    return AiChanProfile(
      userName: userName,
      userCountryCode: 'ES',
      userBirthdate: null,
      aiName: aiName ?? 'AI-chan',
      aiCountryCode: 'JP',
      aiBirthdate: null,
      biography: const {},
      appearance: const {},
      avatars: const [],
    );
  }

  static Future<dynamic> _sendAIRequest(
    final String prompt,
    final String userName,
    final Map<String, String> instructions,
    final List<Map<String, String>> conversationHistory,
    final dynamic aiProviderManager,
  ) async {
    final profile = _createBasicProfile(userName, null);

    final systemPrompt = SystemPrompt(
      profile: profile,
      dateTime: DateTime.now(),
      instructions: instructions,
    );

    // Crear el historial para el procesamiento incluyendo contexto de conversaci√≥n
    final history = List<Map<String, String>>.from(conversationHistory);
    history.add({
      'role': 'system',
      'content': prompt,
      'datetime': DateTime.now().toIso8601String(),
    });

    // Use new AIProviderManager system
    final providerManager = aiProviderManager ?? AIProviderManager.instance;

    final response = await providerManager.sendMessage(
      history: history,
      systemPrompt: systemPrompt,
      capability: AICapability.textGeneration,
    );

    return response;
  }

  /// Crea una respuesta de error consistente para el nuevo formato
  static Map<String, dynamic> _createErrorResponse(
    final String? exception,
    final MemoryData currentMemory,
    final String userResponse,
  ) {
    return {
      'updatedMemory': currentMemory,
      'extractedData': {'type': null, 'value': null},
      'aiResponse': null,
      'error': true,
      'exception': exception,
    };
  }

  /// Helper method to build consistent process result responses
  static Map<String, dynamic> _buildProcessResult({
    required final MemoryData updatedMemory,
    required final Map<String, dynamic> extractedData,
    required final String? aiResponse,
    required final double confidence,
  }) {
    return {
      'updatedMemory': updatedMemory,
      'extractedData': extractedData,
      'aiResponse': aiResponse,
      'confidence': confidence,
      'error': false,
    };
  }
}
